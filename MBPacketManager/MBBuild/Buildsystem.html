<!DOCTYPE html><html><head><style>body{background-color: black; color: #00FF00;}</style></head><body><div style="display: flex"><div style="width: 30%; display: inline-block"><details open=""><summary><a href="../../index.html">/</a></summary><ul><li><a href="../../index.html" >index.mbd</a></li><li><details><summary><a href="../../MBCC/index.html">MBCC</a></summary><ul><li><a href="../../MBCC/index.html" >index.mbd</a></li><li><a href="../../MBCC/CLI.html" >CLI.mbd</a></li><li><a href="../../MBCC/History.html" >History.mbd</a></li></ul></details></li><li><details><summary><a href="../../MBDoc/index.html">MBDoc</a></summary><ul><li><a href="../../MBDoc/index.html" >index.mbd</a></li><li><a href="../../MBDoc/History.html" >History.mbd</a></li><li><a href="../../MBDoc/BuildPipeline.html" >BuildPipeline.mbd</a></li><li><a href="../../MBDoc/Building.html" >Building.mbd</a></li><li><a href="../../MBDoc/Format.html" >Format.mbd</a></li><li><a href="../../MBDoc/Attributes.html" >Attributes.mbd</a></li><li><a href="../../MBDoc/LinkResolving.html" >LinkResolving.mbd</a></li><li><a href="../../MBDoc/CodeIndex.html" >CodeIndex.mbd</a></li><li><a href="../../MBDoc/CLI.html" >CLI.mbd</a></li><li><details><summary><a href="../../MBDoc/Compiler/index.html">Compiler</a></summary><ul><li><a href="../../MBDoc/Compiler/index.html" >index.mbd</a></li></ul></details></li></ul></details></li><li><details open=""><summary><a href="../index.html">MBPacketManager</a></summary><ul><li><a href="../index.html" >index.mbd</a></li><li><a href="../CLI.html" >CLI.mbd</a></li><li><a href="../DevelopmentStructure.html" >DevelopmentStructure.mbd</a></li><li><a href="../Packets.html" >Packets.mbd</a></li><li><a href="../PacketsSpecification.html" >PacketsSpecification.mbd</a></li><li><a href="../SubPackets.html" >SubPackets.mbd</a></li><li><a href="../Extensions.html" >Extensions.mbd</a></li><li><a href="../Terminology.html" >Terminology.mbd</a></li><li><a href="../History.html" >History.mbd</a></li><li><details open=""><summary><a href="index.html">MBBuild</a></summary><ul><li><a href="index.html" >index.mbd</a></li><li><a href="History.html" >History.mbd</a></li><li><mark><a href="" >Buildsystem.mbd</a></mark></li><li><a href="MBCompileConfigurations.html" >MBCompileConfigurations.mbd</a></li><li><a href="MBDependancySpecification.html" >MBDependancySpecification.mbd</a></li><li><a href="MBSourceInfo.html" >MBSourceInfo.mbd</a></li><li><a href="CLI.html" >CLI.mbd</a></li></ul></details></li></ul></details></li></ul></details></div><div style="width: 80ch; display: inline-block; position: absolute; top: 0; left: 0; right: 0; bottom: 0; margin: auto;"><h1 style="text-align: center;">The</h1>
This document describes the abstraction of the buildsystem that is used by mbpm, first giving an overview and discussion of what is neccessary to compile the sources, giving a modell for how compilation is done. This also includes the goals of the buildsystem, aswell as what the buildsystem is intended not to do. It the ends with a concrete specification for how all of the fields in  <a href="MBSourceInfo.html">MBSourceInfo.json</a> and   <a href="MBCompileConfigurations.html">MBCompileConfigurations.json</a> are used in order  to construct the command line used to compile the sources/link the targets. <br><br>

The design behind this buildsystem is derived from the  <a href="History.html">goals of MBBuild</a>. The whole design philosophy can be read about in the <a href="History.html">history of this project</a>, but how these design principles in turn affect and influence the buildsystem are described more concretely here. <br><br>

<h1 id="A buildsystem overview" style = "text-align: center;">1 A buildsystem overview</h1><br>
    There exists a great number of buildsystems out there. <br><br>

    Every buildsystem is intended to solve the deceivingly simple problem of      <i>creating the executable</i>, or library. But some people might wonder why this     is needed, buildsystems can after all be extremly complex, and often times     people ask "how do i compile C++ on linux", in some sense implying that the     way C++ is compiled differs by platform. But it doesn't. What every buildsystem     ultimately boils down to, is a way to invoke the underlying compiler     <i>efficiently</i>. But it is this <i>efficiently</i> that makes the buildsystems so     complex, and so different on different platforms. <br><br>

    Compiling all sources at once is indeed very simple. While not especially     portable, providing a shell file that executes the needed command for every     source is easy. This is the trivial way to implement a buildsystem, but it     quickly runs into a number of problems that more advanced buildsystems     intend to solve. The most obvious flaw of this system, is that it is unable     to handle incremental compilations, that is it compiles all sources every     time wheter or not the source has already been compiled previously. It also     has the problem that changing the flags for the compilation doesn't scale     well, any change for a compile flag has to be mirrored for every source     file. It can also only compile the sources with the same flags, making     switching between "release" and "debug" builds impossible. It also is bad     at determining which libraries are needed at link time, perhaps the most     difficult problem to solve.  <br><br>

    It is in solving all of these problems that the complexity of buildsystems     become apperent. Determining wheter or not a file needs to be recompiled     requires extensive knowledge about the semantics of the compiled language,     and it requires a way to know wheter or not a file itself has been updated.     Changing the flags for all of the sources at once requires that these flags     can be stored and extracted on disk in some capacity, and determining which     libraries needs to be linked is well, if you ask me, something that no     C++ buildsystem I know of really solves. And that is because it      in many ways requires the functionality of a packet manager. <br><br>

    While this might give a perspective why buildsystems are required to do     non-trivial work, so is it ultimately no to complicated. This is not     sufficient to explain why they can be so extremly large and difficult to     understand. And this is where the most fundamental assertion of MBBuild is     comes in: The problem with existing buildsystems are that they are to     expressive and generic. <br><br>

    What I described previously is the process of compiling C++ sources. It is not     neccesarily the process of creating the documentation. It is not neccesarily     the process of configuring the compilation. It is not neccesarily the     process of "installing" the software. But all of these, I would argue     fundamentally different, operations are all usually handled by the same     program. This means that the program has to be able to describe and handle     many different operations, and this in turn leads to the inclusion of      <i>arbitray commands</i>, the inclusion of a programmable behaviour, the     inclusion of user defined behaviour. All of these are things that make     building other peoples code suck. They create a system where a person has to     understand exactly the way every dependancy is compiled, and where modifying     the sources lead to results that are difficult to understand. <br><br>

    This is where difference in philosophy of MBBuild comes in. MBBuild is     intended to be the most minimal system neccessary to compile C/C++/ other     languages with similar semantics. It makes to attempt to be able to compile     any other form of input, and it aims to create a completely standardized way     to compile the code. All of these tenets are summarized in the following     part. <br><br>

<h1 id="MBBuild principles and goals" style = "text-align: center;">2 MBBuild principles and goals</h1><br>
<h2 id="Compile flags are not opaque" >2.1 Compile flags are not opaque</h2><br>
        Compile flags are often times described as a sort of customization,         fiddling and fine tuning the process with options that affect the         behaviour in noticable, but are ultimately an implementation detail.         This is not always the case.  <br><br>

        The are flags that affect the behaviour in ways that are neccessary for         the dependee to know. When using these flags,  <br><br>

<h2 id="Compile flags are never unique to a project" >2.2 Compile flags are never unique to a project</h2><br>
        What this principle says, is that the flags used when compiling packets         rarely form a set of flags that are only applicable to this specific         build. Rather, they always solve a specific problem or achieve a desired         effect.  <br><br>

<h2 id="Configuration is always explicit, not implicit" >2.3 Configuration is always explicit, not implicit</h2><br>
        The quinisenntial form of not interactive configuration is          autoconf. When compiling with this tool, what configurations are made         are often times not easily discerned. Exactly what these  <br><br>

<h2 id="The buildsystem should improve control, not abstract it away" >2.4 The buildsystem should improve control, not abstract it away</h2><br>
<h1 id="MBBuild specification" style = "text-align: center;">3 MBBuild specification</h1><br>
    Compiling C++ in a way that the code compiles with the desired     flags and configurations and what not is one thing, making other people able     to use the result is an entirely different problem. One some systems, the     result of a compilation can usually be "installed", in a way that uses a     system default respected by most applications. The problem with this method     is that it only allows a single configuration to be used, and doesn't allow     a user to modify the process programatically. Other buildsystems, like     CMake allow buildsystems to include other builds, but does like make not     place any restrictions on how these dependancies are compiled, only that     they allow the results to be linked against in a uniform way, placing some     restrictions on the process. MBBuild asserts that in generall, the more     "powerful" and generic a buildsystem is the less guarantees it can make and     the less interoperable it becomes. MBBuild aims for maximal interoperability     and portability, which means that it places firm restrictions on how the     build can be constructed. The way a build is constructed aswell as the     assumption that are used are described here. In particular, all of the     compiler agnostic functionality that are required for a compiler to be used     by mbpm are described here.  <br><br>

<h2 id="Compiler agnostic functionality" >3.1 Compiler agnostic functionality</h2><br>
<h3 id="Include directories" >3.1.1 Include directories</h3><br>
            Every compiler is required to have the ability to add additional             include directories. These directories determines from which             directory header files are searched for. Using the              line '#include &lt;foo/bar&gt;', the header that is located at             "{INCLUDE_DIRECTORY}/foo/bar" if it exists for any value of             INCLUDE_DIRECTORY from the list of include directories. It is             unspecified what happens if multiple include directires contains the             file foo/bar, and builds should not depend on for example the             specific order of include directories.  <br><br>

<h3 id="Output path for compiled sources/linked libraries and executables" >3.1.2 Output path for compiled sources/linked libraries and executables</h3><br>
            MBBuild requires that every output of a compilation can be             designated a specific path. This is because the buildsystems stores             the compiled sources in a compiler agnostic way so that it can             determine the files to link and wheter or not a source is out of             date compiler agnostically. The compiled executables/libraries are             also stored at predetermined locations, which means that these             locations also have to be specified. <br><br>

<h3 id="Link libraries by absolute path" >3.1.3 Link libraries by absolute path</h3><br>
            A compiler must be able to link libraries from an absolute path.             This is used in order to have multiple compiled libraries for             different configurations present on the system. <br><br>

<h3 id="Specify language of sources, and standard used for language" >3.1.4 Specify language of sources, and standard used for language</h3><br>
            Compiling "C" or "C++" is not supported in MBBuild. The only way to             compile "C" is through specifying that the standard you want is             C99, or C89, or whatever standard you want. No programming language             can be compiled in a vacuum, and the only thing defining a             programming language is some form of standard. This             means that being able to demand standard compliance from a compiler             is a neccessity. This does not mean that a compiler must support             all standards, only that the supported standards are explicitly             listed, and that it can specify the standard when needed. <br><br>

<h3 id="Ability to create static library from sources" >3.1.5 Ability to create static library from sources</h3><br>
            A compiler, or more accurately in this case a toolchain, has to             provide a way given a list for sources, to create a static library,             that in turn can be used to resolve symbols for all of the sources             in build depending on these sources. <br><br>

            The distinction between toolchain and compiler here, is that the             compiler frontend does not need to implement this functionality.             Another tool, like ar or lib, provide this functionality, provided             it is guaranteed to work with the output of the compiler. <br><br>

<h3 id="Ability to create dynamic library from sources and dependancies" >3.1.6 Ability to create dynamic library from sources and dependancies</h3><br>
            A compiler, or more accurately in this case a toolchain, has to             provide a way given a list for sources, to create a static library,             that in turn can be used to resolve symbols for all of the sources             in build depending on these sources. <br><br>

            The distinction between toolchain and compiler here, is that the             compiler frontend does not need to implement this functionality.             Another tool can provide this functionality, provided             it is guaranteed to work with the output of the compiler. <br><br>

    Now to define what a <i>build</i> is. This part describes in a more abstract     sense what a build consists of, and how these are in turn serialized is     described at <a href="MBSourceInfo.html">MBSourceInfo.json</a>. <br><br>

<h2 id="Build contents" >3.2 Build contents</h2><br>
        This part exactly what can be specified in a build. Additionally, the         things specified here are assumed to be static, as in not calculated         from some command or determined at runtime. In practice so are all parts         here the contents of the <a href="MBSourceInfo.html">MBSourceInfo.json</a>. <br><br>

<h3 id="Langauge and standard" >3.2.1 Langauge and standard</h3><br>
            Compiling a packet assumes that all sources are of the same language             and standard, meaning that mixed language build aren't implementable             requires different packets. <br><br>

<h3 id="Targets" >3.2.2 Targets</h3><br>
            Targets are the result of a compilation, and can have the type of             either a library or an executable. Libraries can in turn,              with <a href="#" style="color: red;">MBCompileConfigurations.json</a>,             be compiled as either static or dynamic. <br><br>

            A target always consists of a list of sources, and a compiler must             be able to create a library given a list of sources, and any             libraries these sources in turn depend on. <br><br>

            A target also has a name, which specifies the name of the file that             is created as a result of the linking. <br><br>

<h3 id="Dependancies" >3.2.3 Dependancies</h3><br>
            Every compilation has a list of dependancies, which are needed in             order to create the targes and compile the sources. <br><br>

    And that is all that a build consists of. This most notably doesn't allow     the build to specify any form of compile options modifying optimization     levels. This brings aligns with the one of the most core principles of     MBBuild, which is the separation of specifying the build, from determining     the flags added by the configuration and the way dependancies are resolved.     These two last steps are described more in depth at     <a href="MBCompileConfigurations.html">MBCompileConfigurations.json</a> and      <a href="#" style="color: red;">MBDependancySpecification.json</a>. <br><br>

    With all of these definitions, the way a target is compiled can be described     in full. <br><br>

<h1 id="Build process" style = "text-align: center;">4 Build process</h1><br>
        Building a target in a <a href="MBSourceInfo.html">MBSourceInfo.json</a> requires         a valid <a href="MBCompileConfigurations.html">compile configuratino</a> and a          <a href="#" style="color: red;">dependancy specification</a>. <br><br>

        Every <a href="MBCompileConfigurations.html">compile configuration</a> has a name.         First of all, the file         "MBPM_BuildFiles/{CONIGURATION_NAME}/MBDepependancyInfo" is read. If the         file doesn't exist, a new one is created. If the file is in an invalid         format so is an error reported and the building stops. The exact         contents of this file are in turn described         <a href="#" style="color: red;">here</a>, but the functionality it provides is         that given a <a href="MBCompileConfigurations.html">compile configuration</a> and          <a href="MBDependancySpecification.html">dependancy specification</a> so can it         determine wheter or not a given source file needs to be recompiled, or         if a targets needs to be relinked.  <br><br>

        For the given target so are all of it's sources checked for wheter or         not it needs to be compiled, and compiled if it's needed. If the         compilation is unsuccesfull so is the build process terminated with an         error. Otherwise, the <a href="#" style="color: red;">MBDependancyInfo</a>         updated. Then it checks wheter or not the target needs to be relinked.         This can happen even if none of the sources are recompiled, for example         and executable might have libraries it depends on that are updated. <br><br>

        This last part also requires a distinct step that is implemented         compiler agnostically, which is the          <a href="#" style="color: red;">dependant library lookup</a>. This part is also         used when determining wheter or not a target needs to be relinked, and         is documented below. <br><br>

        This gives all of the steps used in how a build is conducted. But is         insufficient in order to understand <i>exactly</i> what is done. Another         design philosophy of MBBuild is that no magic is involved, which means         that all of the steps and the exact command line used to accomplish them         should be able to be determined from only the          <a href="MBSourceInfo.html">MBSourceInfo.json</a>,         <a href="MBCompileConfigurations.html">MBCompileConfigurations.json</a> and         <a href="#" style="color: red;">MBDependancySpecification.json</a>. To         accomplish this, the process for how the command line for the given         process is determined is also documented below, at         <a href="#Toolchains">Toolchains</a>. <br><br>

<h1 id="Dependant library lookup" style = "text-align: center;">5 Dependant library lookup</h1><br>
        The dependnat library lookup constructs a list of absolute paths to the         libraries that needs to be linked to a target. It requires a list of         dependancies, and a         <a href="MBDependancySpecification.html">MBDependancySpecification.json</a>. <br><br>

        First, given a list of dependancies, the total list of dependancies are         calculcated, that all dependancies and transitative dependancies are         retrieved. After that, for each packet, it's packet info is examined for         it's "DefaultLinkTargets". A missing "DefaultLinkTargets" means that the         default link target is used, which is the name of the packet. After         that, the configuration for the dependancy is calculated, as described         in <a href="MBDependancySpecification.html">MBDependancySpecification.json</a>.         Then each path to the link targets for the given compile configuration         is added. <br><br>

<h1 id="Exported include directories" style = "text-align: center;">6 Exported include directories</h1><br>
<h1 id="Target name modification" style = "text-align: center;">7 Target name modification</h1><br>
        The actual filename of a target is modified from it's target name to apply to the operating         systems standard. This part describes how the different target names are         modified for the different targets types in different operating systems.  <br><br>

<h2 id="Windows" >7.1 Windows</h2><br>
<h3 id="Executables" >7.1.1 Executables</h3><br>
                Executables gets the name "{TARGET_NAME}.exe" <br><br>

<h3 id="Libraries" >7.1.2 Libraries</h3><br>
<h4 id="Shared" >7.1.2.1 Shared</h4><br>
                    Shared libraries get the name "{TARGET_NAME}.dll"  <br><br>

<h4 id="Static" >7.1.2.2 Static</h4><br>
                    Static libraries get the name "{TARGET_NAME}.lib" <br><br>

<h2 id="Posix" >7.2 Posix</h2><br>
<h3 id="Executables" >7.2.1 Executables</h3><br>
                Executables gets the name "{TARGET_NAME}" <br><br>

<h3 id="Libraries" >7.2.2 Libraries</h3><br>
<h4 id="Shared" >7.2.2.1 Shared</h4><br>
                    Shared libraries get the name "lib{TARGET_NAME}.so"  <br><br>

<h4 id="Static" >7.2.2.2 Static</h4><br>
                    Static libraries get the name "lib{TARGET_NAME}.a" <br><br>

<h1 id="Toolchains" style = "text-align: center;">8 Toolchains</h1><br>
        This part describes how the command line is constructed for the         different steps, compilation and linking, for the different toolchains,         given the total list of dependancies for the packet, the          <a href="MBCompileConfigurations.html">compilation configuration</a> for the         packet, and the path to all of the          <a href="#" style="color: red;">dependant libraries</a>. <br><br>

        The supported toolchains are gcc,clang, and msvc. Invocation of all of         these commands assume that the executables can be found in the "PATH"         environemntal variable. This in turn also means that only one version of         gcc, clang msvc etc are currently supported. Multiple versions of the         same compiler, with user specified name, is planned to be supported in         the future. <br><br>

<h2 id="gcc" >8.1 gcc</h2><br>
<h3 id="Compilation" >8.1.1 Compilation</h3><br>
                First of all, the name of the executable is determined. If the                 language to compile is C so is gcc used, if it's C++ g++ is                 used. <br><br>

                The first thing added is the standard. The langauge is implicit                 from the version of the compiler name used. The langauge in the                  <a href="MBSourceInfo.html">MBSourceInfo.json</a> is mapped in the followng                 way: <br><br>

<h4 id="Standards" >8.1.1.1 Standards</h4><br>
<h5 id=""Standard"="C99"" >8.1.1.1.1 "Standard"="C99"</h5><br>
                        'std=c99' is added to the command line. <br><br>

<h5 id=""Standard"="C89"" >8.1.1.1.2 "Standard"="C89"</h5><br>
                        'std=c89' is added to the command line. <br><br>

<h5 id=""Standard"="C++17"" >8.1.1.1.3 "Standard"="C++17"</h5><br>
                        'std=c++17' is added to the command line. <br><br>

<h5 id=""Standard"="C++20"" >8.1.1.1.4 "Standard"="C++20"</h5><br>
                        'std=c++20' is added to the command line. <br><br>

                After that, the include directories are added. Include                 directories are added with the -I option. <br><br>

                After that, the name of the source is added. Then, the -o option                 is used to set the output of the resulting object file to                  "MBPM_BuildFiles/{CONFIGURATION_NAME}/{SOURCE_STEM}.o", where                 SOURCE_STEM is the absolute packet path to the source, with the                 filename extension removed.  <br><br>

                After that, all of the                  <a href="MBCompileConfigurations.html">compile flags</a> for the current                 compilation configuration are added as is, separated with                 spaces. <br><br>

<h3 id="Linking" >8.1.2 Linking</h3><br>
                The linking step varies depending on if the target is an                 exectuable or library, and in turn if that library is dynamic or                 not. <br><br>

<h4 id="Executable" >8.1.2.1 Executable</h4><br>
                    As with compilation, first the executable named is                     determined. If the code is C so is gcc used, or if the                     sources are written in C++ g++ is used.  <br><br>

                    The the sources to link are determined. For all sources in                     the current target,                     "MBPM_BuildFiles/{CONFIGURATION_NAME}/{SOURCE_STEM}.o" is                     added to the command line, where {SOURCE_STEM} is the                     <a href="../Terminology.html#Absolute packet path">absolute packet path</a>                     to the source with the filename extension remvoed. <br><br>

                    After that all of the                      <a href="#Dependant library lookup">dependant libraries</a> are added.                     This is done in a extremly hacky way. First the absolute                     path is added to the library search path with the -L option,                     and then the name of the library is added with the -l                     option. Note that the libraries are added in                      <a href="#" style="color: red;">reverse packet order</a>, to                     comply with the way unix linker works, which is by only                     resolving the symbols that the current library specifies the                     currently unresolved symbols. <br><br>

                    After that, the <a href="MBCompileConfigurations.html">linker flags</a>                     are added as is for the current configuration. After that,                     the output name the library is specified, which is                      "MBPM_Builds/{CONFIGURATION_NAME}/{MODIFIED_TARGET_NAME}",                     where {MODIFIED_TARGET_NAME} is the                     <a href="#Target name modification">modified name</a> of the target. <br><br>

<h4 id="Static library" >8.1.2.2 Static library</h4><br>
                    The static library is created with the ar command.  <br><br>

                    First the "ar rcs " is added as the start of the command line.                     The name of the static library is then appended, as                      "MBPM_Builds/{CONFIGURATION_NAME}/{<a href="#Target name modification">{MODIFIED_TARGET_NAME}</a>".                     Then all of the object files are added just like when                     <a href="#" style="color: red;">creating an executable</a>. <br><br>

<mark>Note: </mark>                    Creating static libraries requires that the "ar" executable                     is on path, and in turn that it actually is an executable                     that follows the same semantics as the one provided by                      GNU Binutils. <br><br>

<h4 id="Dynamic library" >8.1.2.3 Dynamic library</h4><br>
                    Dynamic libraries are not currently supported. Supporting                     dynamic libraries most likely imply that additional compile                     time options and link time options are specified, as sources                     need to be compiled with "-fPIC". The main reason that they                     aren't supported yet is that I don't use them, and that                     providing the same semantics for MSVC might provde difficult                     without source level support. <br><br>

<h2 id="clang" >8.2 clang</h2><br>
            The behaviour of clang is exactly the same as for gcc, with the             exception that the compiler name is clang for C code, and clang++             for C++ code. <br><br>

<h2 id="msvc" >8.3 msvc</h2><br>
            MSVC is apparently a toolchain that is not really intended to be             used directly. Unlike GCC so requires it enviroment variables are             correctly set, and exactly which these are not really specified. The             way one is assumed to use it is by first invoking "vcvarsall.bat             x86_x64", where the argument depends on the platform. A problem with             this system, is that this has to be done for every single             source file and target to be linked, which introduces uneccesary             spam and even changes the default terminal settings. Furthermore,             creating dynamic libraries with msvc is not as easy as with unix             compilers. It requires explicitly importing and exporting symbols,             and creating a separate def file to determine which symbols are to             be exported, while unix compilers by default exports every symbol.             This behaviour is what most closely aligns with the principles of              MBBuild, requiring compiler specific macros and files that are only             used on specific platforms reduce the portability, or atleast makes             programming for portability a chore, and furthermore, it should be             equally easy to use both static and dynamic libraries, and the             choice should not lie with the packet being compiled.  <br><br>

            All in all so is the conclusion that the support implemented and the             support possible to implement is not optimal, and is I want all of             the compilers to support the same semantics and operations, so is             the creation of dynamic libraries not implemented. Implementing them              would either require automatic creation if the def file, or allowing             different compilers to implement different capabilities. <br><br>

<h3 id="Compilation" >8.3.1 Compilation</h3><br>
                The first part of the command line in order to compile a                 specific source is "vcvarsall.bat &amp; msvc ", setting up the                 required environment variables and adding the name of the                 compiler. The next step is determining the standard.  <br><br>

<h4 id="Standards" >8.3.1.1 Standards</h4><br>
                    Any standard or language not explicitly listed here means                     that trying to compile for that language + standard                     combination fill fail with an error.  <br><br>

<h5 id="C++" >8.3.1.1.1 C++</h5><br>
<h6 id="C++17" >8.3.1.1.1.1 C++17</h6><br>
                            "/std:c++17 " is added to the command string. <br><br>

<h6 id="C++20" >8.3.1.1.1.2 C++20</h6><br>
                            "/std:c++20 " is added to the command string. <br><br>

<h5 id="C" >8.3.1.1.2 C</h5><br>
<h6 id="C89" >8.3.1.1.2.1 C89</h6><br>
                            C89 isn't really  <br><br>

<h3 id="Linking" >8.3.2 Linking</h3><br>
</div></div></body></html>