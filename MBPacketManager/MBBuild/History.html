<!DOCTYPE html><html><head><style>body{background-color: black; color: #00FF00;}</style></head><body><div style="display: flex"><div style="width: 30%; display: inline-block"><details open=""><summary><a href="../../index.html">/</a></summary><ul><li><a href="../../index.html" >index.mbd</a></li><li><details><summary><a href="../../MBCC/index.html">MBCC</a></summary><ul><li><a href="../../MBCC/index.html" >index.mbd</a></li><li><a href="../../MBCC/CLI.html" >CLI.mbd</a></li><li><a href="../../MBCC/History.html" >History.mbd</a></li></ul></details></li><li><details><summary><a href="../../MBDoc/index.html">MBDoc</a></summary><ul><li><a href="../../MBDoc/index.html" >index.mbd</a></li><li><a href="../../MBDoc/History.html" >History.mbd</a></li><li><a href="../../MBDoc/BuildPipeline.html" >BuildPipeline.mbd</a></li><li><a href="../../MBDoc/Building.html" >Building.mbd</a></li><li><a href="../../MBDoc/Format.html" >Format.mbd</a></li><li><a href="../../MBDoc/Attributes.html" >Attributes.mbd</a></li><li><a href="../../MBDoc/LinkResolving.html" >LinkResolving.mbd</a></li><li><a href="../../MBDoc/CodeIndex.html" >CodeIndex.mbd</a></li><li><a href="../../MBDoc/CLI.html" >CLI.mbd</a></li><li><details><summary><a href="../../MBDoc/Compiler/index.html">Compiler</a></summary><ul><li><a href="../../MBDoc/Compiler/index.html" >index.mbd</a></li></ul></details></li></ul></details></li><li><details open=""><summary><a href="../index.html">MBPacketManager</a></summary><ul><li><a href="../index.html" >index.mbd</a></li><li><a href="../CLI.html" >CLI.mbd</a></li><li><a href="../DevelopmentStructure.html" >DevelopmentStructure.mbd</a></li><li><a href="../Packets.html" >Packets.mbd</a></li><li><a href="../PacketsSpecification.html" >PacketsSpecification.mbd</a></li><li><a href="../SubPackets.html" >SubPackets.mbd</a></li><li><a href="../Extensions.html" >Extensions.mbd</a></li><li><a href="../Terminology.html" >Terminology.mbd</a></li><li><a href="../History.html" >History.mbd</a></li><li><details open=""><summary><a href="index.html">MBBuild</a></summary><ul><li><a href="index.html" >index.mbd</a></li><li><mark><a href="" >History.mbd</a></mark></li><li><a href="Buildsystem.html" >Buildsystem.mbd</a></li><li><a href="MBCompileConfigurations.html" >MBCompileConfigurations.mbd</a></li><li><a href="MBDependancySpecification.html" >MBDependancySpecification.mbd</a></li><li><a href="MBSourceInfo.html" >MBSourceInfo.mbd</a></li><li><a href="CLI.html" >CLI.mbd</a></li></ul></details></li></ul></details></li></ul></details></div><div style="width: 80ch; display: inline-block; position: absolute; top: 0; left: 0; right: 0; bottom: 0; margin: auto;">This document describes the history motivating the project, aswell as the conclusions and design principles that guide the project. The history part is entirely optional and written more as an essay, and can be intresting if one wants to get some context to the project, but all of the goals and design principles are design separately. <br><br>

<h1 id="History" style = "text-align: center;">1 History</h1><br>
The history of MBBuild has a lot of shared history with <a href="../index.html">MBPacketManager</a>, and was originally something that was implicitly included in that functionality, but as that project evolved my needs got more specific and more clear. This project finally crystalized from MBPacketManager when there came a need to make that project more general, and when the exact compile commands became important.  <br><br>

When I first started programming, I mainly used MSBuild and visual studio to compile my projects, configuring the build was very scary. Opening the settings file revealed an absurd amount of options. Gettign the build right required copying the things youtube tutorials did, and without a complete understadning of what everything did I didn't want to touch anything, and the amount of options available made the task of trying to learn what the build system actually did seem sisyphean. <br><br>

When I wanted to be able to compile for Linux I hade to switch to CMake, and in turn I actually hade to learn what everything did. It was during this transition that my first problems with the build systems appeared.  <br><br>

I had understood from a relativly abstract point of view what differenct compile configurations where, and how this was related to debugging and performance. In order to implement cryptograhpic functionality I needed to link to cryptopp, and in order to use these executables I needed to link statically, and used my statically compiled cryptopp library for this purpose. But this lead to very weird and specific link errors. I realised that this was because the compile configurations was incompatible.  <br><br>

This incompatability was what lead to the first incarnation of my own build systrem, which was entirely implemented in MBPacketManager. Calling it a build system might be overstating things, it was a way to insert libraries to link for CMakeFiles defined in a uniform way. But more importantly, the system compiled every library with 2 configurations, one for debug and one for release. This made everything work, and was sufficient for my use cases. But then ffmpeg entered the picture.  <br><br>

Getting ffmpeg to compile for windows is not for the faint of heart. Not only does it take a lot of time and has a gigantic list of configurations, it also requires MinGW or similar. While I didn't reflect much about it at the time, different libraries require different tools for compilation, so has this also gone on to become on of my main gripes. But apart from those complaints so did it also raise another question, what configuration was the finished library? <br><br>

Only having worked with visual studio I hadn't really reflected over the fact that there could be multiple configurations, and when dealing with ffmpeg I simply copied the .lib files and used it for both. This was the first point I realised that not only was the configuration abstraction really faulty, but there also had to be a way to combine different configurations.  <br><br>

Using ffmpeg is an entirely different beast, but needles to say so is the use for library with internal assertions useful. But as compiling ffmpeg sucks, and reading through all of the configruations and options needed I also realised something else, all of the big projects use a completely monolithic build process. It is completely impossible to change which flags are used in a uniform way, while most libraries developed under <i>nix system usally respects the  C_FLAGS environemntal variable so is it far from universal, and many libraries still add their own flags. The only way to know the </i>exact<i> string is to read through the whole makefile. This was especially apperent when ffmpeg needed external libraries like Zlib. I have a zlib that I want to use. How do I tell ffmpeg to use that one? Is it really neccessary for all external libraries to require a involved and library specific step in order to get dependancies right? </i><br><br>

Reading more about the compile flags available I saw that I wanted to use more of my compiler, but I also realised that many flags produce ABI breaking changes, which meant that in order to use my compiler the way I want to I have to enable this options for all my dependancies, which was also the breaking point where I decided to create a new build system that can fullfill these needs. <br><br>

<h1 id="Build system principles" style = "text-align: center;">2 Build system principles</h1><br>
    What follows are the principles that I concluded from my experiences     described in <a href="#History">the history</a>. They include both what a buildsystem     should and should not do, and more generally how code should be shared. <br><br>

<h2 id="I don't want your build system, I want your sources" >2.1 I don't want your build system, I want your sources</h2><br>
        This is perhaps paradoxically the absolutely most fundamental part of         MBBuild, the assertion that build systems are not in any way fundamental         to a project and should idealy be implicitly created.  <br><br>

        This principles expresses the frustration with trying reversee engineer         how a project is compiled from looking at the build files, and has         more implications than what might seem obvious. While an already         configured build system might be convenient, so should it absolutely be         possible to use one's own. <br><br>

<h2 id="Configuring is hard, compiling is easy" >2.2 Configuring is hard, compiling is easy</h2><br>
        When reading documentation of CMake, Make, visual studio or any other         build system, the inclusion of <i>arbitrary commands</i> is often presented         as a killer feature, a way to make the build system infinetly extensible         and do exactly what you need.  <br><br>

        I don't disagree with this, but I do however disagree with the purpose.         The final result of a build system always have to be an invocation to a         compiler, and this invocation can only follow the semantics of the         language. While the sources compiled may be generated from bison, or         header files created that reflects the specific configuration, so are         they in the end just like any other source or header file.  <br><br>

        An alternative formulation of this principle is: <b><i>Arbitrary commands         are only neccessary for configration, not for compiling</b></i>.  <br><br>

        The problem with a lot of buildsystems however, are that these two steps         are rarely separated. I want to be able to compile your source files         with any options that I want, but what source files are part of the         build system is often times obfuscated by all of the other side effects         as a part of the building. But every single operation that is required         before the acutal compilation can always be separated, letting other         people do what they want with finished project. <br><br>

<h2 id="Compile options are not opaque" >2.3 Compile options are not opaque</h2><br>
        A lot of buildsystems treat compile options as a implementation detail,         something that is not required to be completely understood by the         user. This is false.  <br><br>

        Most apparent is with Make build systems. Make is a buildsystems for         arbitrary stuff, which means that compile options are something that         aren't really exposed. The problem here is simply that compilation         options are often times incompatible and in the worst case leads to ABI         incompatability. <br><br>

        The build system should not in any way be the deciding factor of which         compile options are used, and should be completly transparent <i>to the         build system</i>. <br><br>

<h2 id="Dependancys for sources should be auto generated" >2.4 Dependancys for sources should be auto generated</h2><br>
        The way sources and headers depend on each other is something that can         be determined purely through the semantics of the language. Need to         manually specify these dependancys are both error prone and gives the         wrong impression that they should be determined by a human. <br><br>

<h1 id="Project goals" style = "text-align: center;">3 Project goals</h1><br>
    The following part describes the goals for MBBuild, which describes what the     buildsystem and command line application is intended to do. <br><br>

<h2 id="Implicitly generated build system from sources." >3.1 Implicitly generated build system from sources.</h2><br>
        The most fundamental abstraction to whole project, is the idea that         compiling code is actually "easy", atleast in terms of what needs to be         compiled. The user should be able to only specify which source files         constitue a project and be able to compile, and to prodcue executables         needed dependancys. <br><br>

<h2 id="Integrated packet managment system" >3.2 Integrated packet managment system</h2><br>
        This is the goal that makes this in many ways a sibling to         MBPacketManager, packet managment is something that is needed in order         to convieniently create builds. <br><br>

        All non trivial executables and libraries have dependancies. But         specifying and combining libraries should not require absolute paths or         any form of mandatory directory structure that needs to be maintained         for all projects.  <br><br>

<h2 id="Easy global configuration specification and mixing and matching for builds" >3.3 Easy global configuration specification and mixing and matching for builds</h2><br>
        This goal is in some ways contradictory to previous goals, that the         configuration for a build should not be specified by the build. This is         still true, but there still needs to be a way to specify a build with         specific configurations. They main reason why, is that some projects are         expensive to rebuild for a specific configuration, for example ffmpeg or         LLVM. In order to be able to specify the compile flags used in a         compilation so must there be away to have a build that let's dependancys         use different configurations. <br><br>

</div></div></body></html>